
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">com.moguyn/mcp-go-search/config/config.go (89.7%)</option>
				
				<option value="file1">com.moguyn/mcp-go-search/main.go (0.0%)</option>
				
				<option value="file2">com.moguyn/mcp-go-search/mcp/tools.go (93.8%)</option>
				
				<option value="file3">com.moguyn/mcp-go-search/search/service.go (80.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "log"
        "os"
        "strconv"
        "time"
)

// Config holds the application configuration
type Config struct {
        // API configuration
        BochaAPIKey     string
        BochaAPIBaseURL string
        HTTPTimeout     time.Duration

        // Server configuration
        ServerName    string
        ServerVersion string
}

// New creates a new configuration with values from environment variables
func New() *Config <span class="cov8" title="1">{
        config := &amp;Config{
                // Default values
                BochaAPIKey:     os.Getenv("BOCHA_API_KEY"),
                BochaAPIBaseURL: getEnvWithDefault("BOCHA_API_BASE_URL", "https://api.bochaai.com/v1/ai-search"),
                HTTPTimeout:     getEnvDurationWithDefault("HTTP_TIMEOUT", 10*time.Second),
                ServerName:      getEnvWithDefault("SERVER_NAME", "Bocha AI Search Server"),
                ServerVersion:   getEnvWithDefault("SERVER_VERSION", "1.0.0"),
        }

        // Validate required configuration
        if config.BochaAPIKey == "" </span><span class="cov8" title="1">{
                log.Println("Warning: BOCHA_API_KEY environment variable not set. The search service will not work without an API key.")
        }</span>

        // Validate HTTP timeout
        <span class="cov8" title="1">if config.HTTPTimeout &lt; time.Second </span><span class="cov0" title="0">{
                log.Printf("Warning: HTTP_TIMEOUT is very short (%s). Setting to minimum of 1 second.", config.HTTPTimeout)
                config.HTTPTimeout = time.Second
        }</span> else<span class="cov8" title="1"> if config.HTTPTimeout &gt; 60*time.Second </span><span class="cov0" title="0">{
                log.Printf("Warning: HTTP_TIMEOUT is very long (%s). This may cause requests to hang.", config.HTTPTimeout)
        }</span>

        <span class="cov8" title="1">return config</span>
}

// Validate performs additional validation on the configuration
// and returns an error if the configuration is invalid
func (c *Config) Validate() error <span class="cov8" title="1">{
        if c.BochaAPIKey == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("BOCHA_API_KEY environment variable is required")
        }</span>

        <span class="cov8" title="1">if c.BochaAPIBaseURL == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("BOCHA_API_BASE_URL cannot be empty")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getEnvWithDefault returns the value of the environment variable or the default value if not set
func getEnvWithDefault(key, defaultValue string) string <span class="cov8" title="1">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov8" title="1">{
                return defaultValue
        }</span>
        <span class="cov8" title="1">return value</span>
}

// getEnvDurationWithDefault returns the duration from the environment variable or the default value if not set
func getEnvDurationWithDefault(key string, defaultValue time.Duration) time.Duration <span class="cov8" title="1">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov8" title="1">{
                return defaultValue
        }</span>

        // Try to parse as seconds
        <span class="cov8" title="1">seconds, err := strconv.Atoi(value)
        if err == nil </span><span class="cov8" title="1">{
                return time.Duration(seconds) * time.Second
        }</span>

        // Try to parse as duration string
        <span class="cov8" title="1">duration, err := time.ParseDuration(value)
        if err == nil </span><span class="cov8" title="1">{
                return duration
        }</span>

        // Return default if parsing fails
        <span class="cov8" title="1">log.Printf("Warning: Could not parse %s as duration, using default of %s", key, defaultValue)
        return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "log"
        "os"

        "github.com/mark3labs/mcp-go/server"

        "com.moguyn/mcp-go-search/config"
        "com.moguyn/mcp-go-search/mcp"
        "com.moguyn/mcp-go-search/search"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg := config.New()

        // Validate configuration
        if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Configuration error: %v", err)
                log.Println("Please set the BOCHA_API_KEY environment variable.")
                log.Println("Example: export BOCHA_API_KEY=\"your-api-key-here\"")
                os.Exit(1)
        }</span>

        // Create a new MCP server
        <span class="cov0" title="0">s := server.NewMCPServer(
                cfg.ServerName,
                cfg.ServerVersion,
                server.WithLogging(),
        )

        // Create the search service
        searchService := search.NewBochaServiceWithConfig(cfg)

        // Create the search tool
        searchTool := mcp.NewSearchTool(searchService)

        // Add the search tool to the server
        s.AddTool(searchTool.Definition(), searchTool.Handler())

        // Start the server
        log.Printf("Starting %s v%s...", cfg.ServerName, cfg.ServerVersion)
        if err := server.ServeStdio(s); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Server error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package mcp

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/mark3labs/mcp-go/mcp"

        "com.moguyn/mcp-go-search/search"
)

// SearchTool provides the search functionality as an MCP tool
type SearchTool struct {
        searchService search.Service
}

// NewSearchTool creates a new search tool with the provided search service
func NewSearchTool(searchService search.Service) *SearchTool <span class="cov8" title="1">{
        return &amp;SearchTool{
                searchService: searchService,
        }
}</span>

// Definition returns the MCP tool definition
func (t *SearchTool) Definition() mcp.Tool <span class="cov8" title="1">{
        return mcp.NewTool("search",
                mcp.WithDescription("Search the web using Bocha AI Search API"),
                mcp.WithString("query",
                        mcp.Required(),
                        mcp.Description("The search query"),
                ),
                mcp.WithString("freshness",
                        mcp.Description("Filter results by freshness (noLimit, day, week, month)"),
                        mcp.Enum("noLimit", "day", "week", "month"),
                ),
                mcp.WithNumber("count",
                        mcp.Description("Number of results to return (1-50)"),
                ),
                mcp.WithBoolean("answer",
                        mcp.Description("Whether to generate an answer based on search results"),
                ),
        )
}</span>

// Handler returns the MCP tool handler function
func (t *SearchTool) Handler() func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) <span class="cov8" title="1">{
        return func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov8" title="1">{
                // Extract parameters from the request
                query, ok := request.Params.Arguments["query"].(string)
                if !ok || query == "" </span><span class="cov8" title="1">{
                        return mcp.NewToolResultError("query parameter is required and must be a string"), nil
                }</span>

                // Extract optional parameters with defaults
                <span class="cov8" title="1">freshness := "noLimit"
                if f, ok := request.Params.Arguments["freshness"].(string); ok &amp;&amp; f != "" </span><span class="cov8" title="1">{
                        freshness = f
                }</span>

                <span class="cov8" title="1">count := 10
                if c, ok := request.Params.Arguments["count"].(float64); ok </span><span class="cov8" title="1">{
                        count = int(c)
                        // Ensure count is within valid range
                        if count &lt; 1 </span><span class="cov0" title="0">{
                                count = 1
                        }</span> else<span class="cov8" title="1"> if count &gt; 50 </span><span class="cov0" title="0">{
                                count = 50
                        }</span>
                }

                <span class="cov8" title="1">answer := false
                if a, ok := request.Params.Arguments["answer"].(bool); ok </span><span class="cov8" title="1">{
                        answer = a
                }</span>

                // Perform the search
                <span class="cov8" title="1">response, err := t.searchService.Search(ctx, query, freshness, count, answer)
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError(fmt.Sprintf("Search failed: %v", err)), nil
                }</span>

                // Format the results
                <span class="cov8" title="1">var resultBuilder strings.Builder

                // Add search metadata
                resultBuilder.WriteString(fmt.Sprintf("Search Query: \"%s\"\n", query))
                resultBuilder.WriteString(fmt.Sprintf("Freshness: %s\n", formatFreshness(freshness)))
                resultBuilder.WriteString(fmt.Sprintf("Results: %d\n\n", len(response.Results)))

                // Add answer if available
                if answer &amp;&amp; response.Answer != "" </span><span class="cov8" title="1">{
                        resultBuilder.WriteString("Answer:\n")
                        resultBuilder.WriteString(response.Answer)
                        resultBuilder.WriteString("\n\n")
                }</span>

                // Add search results
                <span class="cov8" title="1">resultBuilder.WriteString("Search Results:\n")
                resultBuilder.WriteString("==============\n\n")

                for i, result := range response.Results </span><span class="cov8" title="1">{
                        resultBuilder.WriteString(fmt.Sprintf("%d. %s\n", i+1, result.Title))
                        resultBuilder.WriteString(fmt.Sprintf("   URL: %s\n", result.URL))

                        // Add date published if available
                        if result.DatePublished != "" </span><span class="cov8" title="1">{
                                resultBuilder.WriteString(fmt.Sprintf("   Published: %s\n", formatDate(result.DatePublished)))
                        }</span>

                        <span class="cov8" title="1">resultBuilder.WriteString(fmt.Sprintf("   %s\n\n", result.Description))</span>
                }

                <span class="cov8" title="1">return mcp.NewToolResultText(resultBuilder.String()), nil</span>
        }
}

// formatFreshness returns a human-readable string for the freshness parameter
func formatFreshness(freshness string) string <span class="cov8" title="1">{
        switch freshness </span>{
        case "day":<span class="cov8" title="1">
                return "Past 24 hours"</span>
        case "week":<span class="cov8" title="1">
                return "Past week"</span>
        case "month":<span class="cov8" title="1">
                return "Past month"</span>
        default:<span class="cov8" title="1">
                return "No time limit"</span>
        }
}

// formatDate attempts to format the date in a more readable format
func formatDate(dateStr string) string <span class="cov8" title="1">{
        // Try to parse the date
        for _, layout := range []string{
                time.RFC3339,
                "2006-01-02T15:04:05Z",
                "2006-01-02",
        } </span><span class="cov8" title="1">{
                if t, err := time.Parse(layout, dateStr); err == nil </span><span class="cov8" title="1">{
                        return t.Format("January 2, 2006")
                }</span>
        }

        // Return the original string if parsing fails
        <span class="cov8" title="1">return dateStr</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package search

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "com.moguyn/mcp-go-search/config"
)

// Request represents the request structure for the Bocha AI Search API
type Request struct {
        Query     string `json:"query"`
        Freshness string `json:"freshness"`
        Count     int    `json:"count"`
        Answer    bool   `json:"answer"`
        Stream    bool   `json:"stream"`
}

// Result represents a single search result from the Bocha AI Search API
type Result struct {
        Title         string `json:"title"`
        URL           string `json:"url"`
        Description   string `json:"description"`
        DatePublished string `json:"datePublished,omitempty"`
}

// Response represents the response structure from the Bocha AI Search API
type Response struct {
        Results []Result `json:"results"`
        Answer  string   `json:"answer,omitempty"`
}

// Service defines the interface for search operations
type Service interface {
        Search(ctx context.Context, query string, freshness string, count int, answer bool) (*Response, error)
}

// BochaService implements the Service interface for Bocha AI Search API
type BochaService struct {
        apiKey     string
        apiBaseURL string
        httpClient *http.Client
}

// NewBochaService creates a new instance of the BochaService
func NewBochaService() *BochaService <span class="cov8" title="1">{
        return NewBochaServiceWithConfig(config.New())
}</span>

// NewBochaServiceWithConfig creates a new instance of the BochaService with the provided configuration
func NewBochaServiceWithConfig(cfg *config.Config) *BochaService <span class="cov8" title="1">{
        return &amp;BochaService{
                apiKey:     cfg.BochaAPIKey,
                apiBaseURL: cfg.BochaAPIBaseURL,
                httpClient: &amp;http.Client{
                        Timeout: cfg.HTTPTimeout,
                },
        }
}</span>

// Search performs a search using the Bocha AI Search API
func (s *BochaService) Search(ctx context.Context, query string, freshness string, count int, answer bool) (*Response, error) <span class="cov8" title="1">{
        // Validate inputs
        if query == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("search query cannot be empty")
        }</span>

        <span class="cov8" title="1">if count &lt; 1 </span><span class="cov8" title="1">{
                count = 1
        }</span> else<span class="cov8" title="1"> if count &gt; 50 </span><span class="cov8" title="1">{
                count = 50
        }</span>

        // Create the request payload
        <span class="cov8" title="1">reqBody := Request{
                Query:     query,
                Freshness: freshness,
                Count:     count,
                Answer:    answer,
                Stream:    false, // We don't support streaming in this implementation
        }

        // Convert the request to JSON
        jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        // Create the HTTP request
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "POST", s.apiBaseURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        // Set headers
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", s.apiKey))

        // Send the request
        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request to Bocha API: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Read the response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read Bocha API response body: %w", err)
        }</span>

        // Check for non-200 status code
        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Bocha API returned status code %d: %s", resp.StatusCode, string(body))
        }</span>

        // Parse the response
        <span class="cov8" title="1">var searchResp Response
        if err := json.Unmarshal(body, &amp;searchResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse Bocha API response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;searchResp, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
