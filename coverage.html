
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">com.moguyn/mcp-go-search/config/config.go (91.0%)</option>
				
				<option value="file1">com.moguyn/mcp-go-search/main.go (88.5%)</option>
				
				<option value="file2">com.moguyn/mcp-go-search/mcp/tools.go (89.5%)</option>
				
				<option value="file3">com.moguyn/mcp-go-search/search/service.go (89.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "log"
        "os"
        "strconv"
        "time"

        "gopkg.in/yaml.v3"
)

// Config holds the application configuration
type Config struct {
        // API configuration
        BochaAPIKey     string        `yaml:"bocha_api_key" json:"bocha_api_key"`
        BochaAPIBaseURL string        `yaml:"bocha_api_base_url" json:"bocha_api_base_url"`
        HTTPTimeout     time.Duration `yaml:"-" json:"-"` // Custom handling for YAML/JSON

        // Server configuration
        ServerName    string `yaml:"server_name" json:"server_name"`
        ServerVersion string `yaml:"server_version" json:"server_version"`

        // Internal fields not for YAML/JSON
        HTTPTimeoutStr string `yaml:"http_timeout" json:"http_timeout"`
}

// New creates a new configuration with values from environment variables
func New() *Config <span class="cov8" title="1">{
        config := &amp;Config{
                // Default values
                BochaAPIKey:     os.Getenv("BOCHA_API_KEY"),
                BochaAPIBaseURL: getEnvWithDefault("BOCHA_API_BASE_URL", "https://api.bochaai.com/v1/ai-search"),
                HTTPTimeout:     getEnvDurationWithDefault("HTTP_TIMEOUT", 10*time.Second),
                ServerName:      getEnvWithDefault("SERVER_NAME", "Bocha AI Search Server"),
                ServerVersion:   getEnvWithDefault("SERVER_VERSION", "1.0.0"),
        }

        // Check if a config file path is provided
        configPath := os.Getenv("CONFIG_FILE")
        if configPath != "" </span><span class="cov0" title="0">{
                if err := config.LoadFromFile(configPath); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to load config from file %s: %v", configPath, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Warning: Using configuration file for sensitive data like API keys is not recommended for production environments")
                }</span>
        }

        // Environment variables take precedence over config file
        <span class="cov8" title="1">if envAPIKey := os.Getenv("BOCHA_API_KEY"); envAPIKey != "" </span><span class="cov8" title="1">{
                config.BochaAPIKey = envAPIKey
        }</span>
        <span class="cov8" title="1">if envAPIBaseURL := os.Getenv("BOCHA_API_BASE_URL"); envAPIBaseURL != "" </span><span class="cov8" title="1">{
                config.BochaAPIBaseURL = envAPIBaseURL
        }</span>
        <span class="cov8" title="1">if envHTTPTimeout := os.Getenv("HTTP_TIMEOUT"); envHTTPTimeout != "" </span><span class="cov8" title="1">{
                config.HTTPTimeout = getEnvDurationWithDefault("HTTP_TIMEOUT", config.HTTPTimeout)
        }</span>
        <span class="cov8" title="1">if envServerName := os.Getenv("SERVER_NAME"); envServerName != "" </span><span class="cov8" title="1">{
                config.ServerName = envServerName
        }</span>
        <span class="cov8" title="1">if envServerVersion := os.Getenv("SERVER_VERSION"); envServerVersion != "" </span><span class="cov8" title="1">{
                config.ServerVersion = envServerVersion
        }</span>

        // Validate required configuration
        <span class="cov8" title="1">if config.BochaAPIKey == "" </span><span class="cov8" title="1">{
                log.Println("Warning: BOCHA_API_KEY environment variable not set. The search service will not work without an API key.")
        }</span>

        // Validate HTTP timeout
        <span class="cov8" title="1">if config.HTTPTimeout &lt; time.Second </span><span class="cov0" title="0">{
                log.Printf("Warning: HTTP_TIMEOUT is very short (%s). Setting to minimum of 1 second.", config.HTTPTimeout)
                config.HTTPTimeout = time.Second
        }</span> else<span class="cov8" title="1"> if config.HTTPTimeout &gt; 60*time.Second </span><span class="cov0" title="0">{
                log.Printf("Warning: HTTP_TIMEOUT is very long (%s). This may cause requests to hang.", config.HTTPTimeout)
        }</span>

        <span class="cov8" title="1">return config</span>
}

// LoadFromFile loads configuration from a YAML file
func (c *Config) LoadFromFile(path string) error <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Create a temporary config to unmarshal into
        <span class="cov8" title="1">var fileConfig Config
        if err := yaml.Unmarshal(data, &amp;fileConfig); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Apply non-empty values from the file config
        <span class="cov8" title="1">if fileConfig.BochaAPIKey != "" </span><span class="cov8" title="1">{
                c.BochaAPIKey = fileConfig.BochaAPIKey
        }</span>
        <span class="cov8" title="1">if fileConfig.BochaAPIBaseURL != "" </span><span class="cov8" title="1">{
                c.BochaAPIBaseURL = fileConfig.BochaAPIBaseURL
        }</span>
        <span class="cov8" title="1">if fileConfig.HTTPTimeoutStr != "" </span><span class="cov8" title="1">{
                duration, err := time.ParseDuration(fileConfig.HTTPTimeoutStr)
                if err == nil </span><span class="cov8" title="1">{
                        c.HTTPTimeout = duration
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("Warning: Invalid HTTP timeout in config file: %s", fileConfig.HTTPTimeoutStr)
                }</span>
        }
        <span class="cov8" title="1">if fileConfig.ServerName != "" </span><span class="cov8" title="1">{
                c.ServerName = fileConfig.ServerName
        }</span>
        <span class="cov8" title="1">if fileConfig.ServerVersion != "" </span><span class="cov8" title="1">{
                c.ServerVersion = fileConfig.ServerVersion
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Validate performs additional validation on the configuration
// and returns an error if the configuration is invalid
func (c *Config) Validate() error <span class="cov8" title="1">{
        if c.BochaAPIKey == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("BOCHA_API_KEY environment variable is required")
        }</span>

        <span class="cov8" title="1">if c.BochaAPIBaseURL == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("BOCHA_API_BASE_URL cannot be empty")
        }</span>

        // Log a masked version of the API key for debugging
        <span class="cov8" title="1">if len(c.BochaAPIKey) &gt; 8 </span><span class="cov8" title="1">{
                maskedKey := c.BochaAPIKey[:4] + "..." + c.BochaAPIKey[len(c.BochaAPIKey)-4:]
                log.Printf("Using Bocha API key: %s", maskedKey)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getEnvWithDefault returns the value of the environment variable or the default value if not set
func getEnvWithDefault(key, defaultValue string) string <span class="cov8" title="1">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov8" title="1">{
                return defaultValue
        }</span>
        <span class="cov8" title="1">return value</span>
}

// getEnvDurationWithDefault returns the duration from the environment variable or the default value if not set
func getEnvDurationWithDefault(key string, defaultValue time.Duration) time.Duration <span class="cov8" title="1">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov8" title="1">{
                return defaultValue
        }</span>

        // Try to parse as seconds
        <span class="cov8" title="1">seconds, err := strconv.Atoi(value)
        if err == nil </span><span class="cov8" title="1">{
                return time.Duration(seconds) * time.Second
        }</span>

        // Try to parse as duration string
        <span class="cov8" title="1">duration, err := time.ParseDuration(value)
        if err == nil </span><span class="cov8" title="1">{
                return duration
        }</span>

        // Return default if parsing fails
        <span class="cov8" title="1">log.Printf("Warning: Could not parse %s as duration, using default of %s", key, defaultValue)
        return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "log"
        "os"
        "time"

        "github.com/mark3labs/mcp-go/server"

        "com.moguyn/mcp-go-search/config"
        "com.moguyn/mcp-go-search/mcp"
        "com.moguyn/mcp-go-search/search"
)

// Logger provides a simple structured logging interface
type Logger struct {
        prefix string
}

// NewLogger creates a new logger with the given prefix
func NewLogger(prefix string) *Logger <span class="cov8" title="1">{
        return &amp;Logger{prefix: prefix}
}</span>

// Info logs an informational message with structured data
func (l *Logger) Info(msg string, data map[string]interface{}) <span class="cov8" title="1">{
        l.log("INFO", msg, data)
}</span>

// Error logs an error message with structured data
func (l *Logger) Error(msg string, err error, data map[string]interface{}) <span class="cov8" title="1">{
        if data == nil </span><span class="cov0" title="0">{
                data = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                data["error"] = err.Error()
        }</span>
        <span class="cov8" title="1">l.log("ERROR", msg, data)</span>
}

// log formats and prints a log message
func (l *Logger) log(level, msg string, data map[string]interface{}) <span class="cov8" title="1">{
        timestamp := time.Now().Format(time.RFC3339)

        // Format the data as key=value pairs
        dataStr := ""
        for k, v := range data </span><span class="cov8" title="1">{
                dataStr += fmt.Sprintf(" %s=%v", k, v)
        }</span>

        <span class="cov8" title="1">log.Printf("%s [%s] %s: %s%s", timestamp, level, l.prefix, msg, dataStr)</span>
}

// serveStdio is a variable that can be overridden in tests
var serveStdio = server.ServeStdio

// runServer is the main application logic, extracted for testability
func runServer() error <span class="cov8" title="1">{
        logger := NewLogger("main")

        // Log startup
        logger.Info("Starting server", map[string]interface{}{
                "time": time.Now().Format(time.RFC3339),
        })

        // Load configuration
        cfg := config.New()

        // Validate configuration
        if err := cfg.Validate(); err != nil </span><span class="cov8" title="1">{
                logger.Error("Configuration error", err, map[string]interface{}{
                        "suggestion": "Please set the BOCHA_API_KEY environment variable.",
                })
                return err
        }</span>

        // Create a new MCP server
        <span class="cov8" title="1">s := server.NewMCPServer(
                cfg.ServerName,
                cfg.ServerVersion,
                server.WithLogging(),
        )

        // Create the search service
        searchService := search.NewBochaServiceWithConfig(cfg)

        // Create the search tool
        searchTool := mcp.NewSearchTool(searchService)

        // Add the search tool to the server
        s.AddTool(searchTool.Definition(), searchTool.Handler())

        // Start the server
        logger.Info("Server ready", map[string]interface{}{
                "name":    cfg.ServerName,
                "version": cfg.ServerVersion,
        })

        return serveStdio(s)</span>
}

func main() <span class="cov0" title="0">{
        if err := runServer(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package mcp

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/mark3labs/mcp-go/mcp"

        "com.moguyn/mcp-go-search/search"
)

// SearchTool provides the search functionality as an MCP tool
type SearchTool struct {
        searchService search.Service
}

// NewSearchTool creates a new search tool with the provided search service
func NewSearchTool(searchService search.Service) *SearchTool <span class="cov8" title="1">{
        return &amp;SearchTool{
                searchService: searchService,
        }
}</span>

// Definition returns the MCP tool definition
func (t *SearchTool) Definition() mcp.Tool <span class="cov8" title="1">{
        return mcp.NewTool("search",
                mcp.WithDescription("Search the web using Bocha AI Search API"),
                mcp.WithString("query",
                        mcp.Required(),
                        mcp.Description("The search query"),
                ),
                mcp.WithString("freshness",
                        mcp.Description("Filter results by freshness (noLimit, day, week, month)"),
                        mcp.Enum("noLimit", "day", "week", "month"),
                ),
                mcp.WithNumber("count",
                        mcp.Description("Number of results to return (1-50)"),
                ),
                mcp.WithBoolean("answer",
                        mcp.Description("Whether to generate an answer based on search results"),
                ),
        )
}</span>

// Handler returns the MCP tool handler function
func (t *SearchTool) Handler() func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) <span class="cov8" title="1">{
        return func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov8" title="1">{
                // Create a timeout context to prevent long-running searches
                ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
                defer cancel()

                // Extract parameters from the request
                query, ok := request.Params.Arguments["query"].(string)
                if !ok || query == "" </span><span class="cov8" title="1">{
                        return mcp.NewToolResultError("query parameter is required and must be a string"), nil
                }</span>

                // Validate query length to prevent abuse
                <span class="cov8" title="1">if len(query) &gt; 1000 </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError("query is too long (maximum 1000 characters)"), nil
                }</span>

                // Extract optional parameters with defaults
                <span class="cov8" title="1">freshness := "noLimit"
                if f, ok := request.Params.Arguments["freshness"].(string); ok &amp;&amp; f != "" </span><span class="cov8" title="1">{
                        // Validate freshness parameter
                        if f != "noLimit" &amp;&amp; f != "day" &amp;&amp; f != "week" &amp;&amp; f != "month" </span><span class="cov0" title="0">{
                                return mcp.NewToolResultError(fmt.Sprintf("invalid freshness value: %q, must be one of: noLimit, day, week, month", f)), nil
                        }</span>
                        <span class="cov8" title="1">freshness = f</span>
                }

                <span class="cov8" title="1">count := 10
                if c, ok := request.Params.Arguments["count"].(float64); ok </span><span class="cov8" title="1">{
                        count = int(c)
                        // Ensure count is within valid range
                        if count &lt; 1 </span><span class="cov0" title="0">{
                                count = 1
                        }</span> else<span class="cov8" title="1"> if count &gt; 50 </span><span class="cov0" title="0">{
                                count = 50
                        }</span>
                }

                <span class="cov8" title="1">answer := false
                if a, ok := request.Params.Arguments["answer"].(bool); ok </span><span class="cov8" title="1">{
                        answer = a
                }</span>

                // Perform the search
                <span class="cov8" title="1">response, err := t.searchService.Search(ctx, query, freshness, count, answer)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle context cancellation
                        if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                                return mcp.NewToolResultError("Search timed out after 30 seconds"), nil
                        }</span>

                        // Sanitize error message to prevent leaking sensitive information
                        <span class="cov0" title="0">errMsg := sanitizeErrorMessage(err.Error())
                        return mcp.NewToolResultError(fmt.Sprintf("Search failed: %v", errMsg)), nil</span>
                }

                // Format the results
                <span class="cov8" title="1">var resultBuilder strings.Builder

                // Add search metadata
                resultBuilder.WriteString(fmt.Sprintf("Search Query: \"%s\"\n", query))
                resultBuilder.WriteString(fmt.Sprintf("Freshness: %s\n", formatFreshness(freshness)))
                resultBuilder.WriteString(fmt.Sprintf("Results: %d\n\n", len(response.Results)))

                // Add answer if available
                if answer &amp;&amp; response.Answer != "" </span><span class="cov8" title="1">{
                        resultBuilder.WriteString("Answer:\n")
                        resultBuilder.WriteString(response.Answer)
                        resultBuilder.WriteString("\n\n")
                }</span>

                // Add search results
                <span class="cov8" title="1">resultBuilder.WriteString("Search Results:\n")
                resultBuilder.WriteString("==============\n\n")

                for i, result := range response.Results </span><span class="cov8" title="1">{
                        resultBuilder.WriteString(fmt.Sprintf("%d. %s\n", i+1, result.Title))
                        resultBuilder.WriteString(fmt.Sprintf("   URL: %s\n", result.URL))

                        // Add date published if available
                        if result.DatePublished != "" </span><span class="cov8" title="1">{
                                resultBuilder.WriteString(fmt.Sprintf("   Published: %s\n", formatDate(result.DatePublished)))
                        }</span>

                        <span class="cov8" title="1">resultBuilder.WriteString(fmt.Sprintf("   %s\n\n", result.Description))</span>
                }

                <span class="cov8" title="1">return mcp.NewToolResultText(resultBuilder.String()), nil</span>
        }
}

// formatFreshness returns a human-readable string for the freshness parameter
func formatFreshness(freshness string) string <span class="cov8" title="1">{
        switch freshness </span>{
        case "day":<span class="cov8" title="1">
                return "Past 24 hours"</span>
        case "week":<span class="cov8" title="1">
                return "Past week"</span>
        case "month":<span class="cov8" title="1">
                return "Past month"</span>
        default:<span class="cov8" title="1">
                return "No time limit"</span>
        }
}

// formatDate attempts to format the date in a more readable format
func formatDate(dateStr string) string <span class="cov8" title="1">{
        // Try to parse the date
        for _, layout := range []string{
                time.RFC3339,
                "2006-01-02T15:04:05Z",
                "2006-01-02",
        } </span><span class="cov8" title="1">{
                if t, err := time.Parse(layout, dateStr); err == nil </span><span class="cov8" title="1">{
                        return t.Format("January 2, 2006")
                }</span>
        }

        // Return the original string if parsing fails
        <span class="cov8" title="1">return dateStr</span>
}

// sanitizeErrorMessage removes potentially sensitive information from error messages
func sanitizeErrorMessage(errMsg string) string <span class="cov8" title="1">{
        // Remove any API keys that might be in the error message
        // This is a simple implementation - in a production environment,
        // you might want to use a more sophisticated approach
        if strings.Contains(errMsg, "Bearer ") </span><span class="cov8" title="1">{
                parts := strings.Split(errMsg, "Bearer ")
                if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        // Find the end of the token
                        tokenEnd := strings.IndexAny(parts[1], " \t\n\r\",;:)")
                        if tokenEnd != -1 </span><span class="cov8" title="1">{
                                parts[1] = "[REDACTED]" + parts[1][tokenEnd:]
                                errMsg = strings.Join(parts, "Bearer ")
                        }</span> else<span class="cov8" title="1"> {
                                // If we can't find the end of the token, it might be at the end of the string
                                parts[1] = "[REDACTED]"
                                errMsg = strings.Join(parts, "Bearer ")
                        }</span>
                }
        }

        // Remove any URLs that might contain sensitive information
        <span class="cov8" title="1">if strings.Contains(errMsg, "http") </span><span class="cov8" title="1">{
                // Simple regex-like replacement for URLs
                for _, prefix := range []string{"http://", "https://"} </span><span class="cov8" title="1">{
                        if idx := strings.Index(errMsg, prefix); idx != -1 </span><span class="cov8" title="1">{
                                start := idx
                                end := start + len(prefix)
                                // Find the end of the URL
                                for end &lt; len(errMsg) &amp;&amp; !strings.ContainsAny(string(errMsg[end]), " \t\n\r\",;:)") </span><span class="cov8" title="1">{
                                        end++
                                }</span>
                                <span class="cov8" title="1">if end &gt; start+len(prefix) </span><span class="cov8" title="1">{
                                        errMsg = errMsg[:start] + "[URL REDACTED]" + errMsg[end:]
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return errMsg</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package search

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "golang.org/x/time/rate"

        "com.moguyn/mcp-go-search/config"
)

// Request represents the request structure for the Bocha AI Search API
type Request struct {
        Query     string `json:"query"`
        Freshness string `json:"freshness"`
        Count     int    `json:"count"`
        Answer    bool   `json:"answer"`
        Stream    bool   `json:"stream"`
}

// Result represents a single search result from the Bocha AI Search API
type Result struct {
        Title         string `json:"title"`
        URL           string `json:"url"`
        Description   string `json:"description"`
        DatePublished string `json:"datePublished,omitempty"`
}

// Response represents the response structure from the Bocha AI Search API
type Response struct {
        Results []Result `json:"results"`
        Answer  string   `json:"answer,omitempty"`
}

// Service defines the interface for search operations
type Service interface {
        Search(ctx context.Context, query string, freshness string, count int, answer bool) (*Response, error)
}

// BochaService implements the Service interface for Bocha AI Search API
type BochaService struct {
        apiKey      string
        apiBaseURL  string
        httpClient  *http.Client
        rateLimiter *rate.Limiter
}

// NewBochaService creates a new instance of the BochaService
func NewBochaService() *BochaService <span class="cov8" title="1">{
        return NewBochaServiceWithConfig(config.New())
}</span>

// NewBochaServiceWithConfig creates a new instance of the BochaService with the provided configuration
func NewBochaServiceWithConfig(cfg *config.Config) *BochaService <span class="cov8" title="1">{
        // Create a secure transport with modern TLS configuration
        transport := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        MinVersion: tls.VersionTLS12,
                },
                ForceAttemptHTTP2: true,
                MaxIdleConns:      100,
                IdleConnTimeout:   90 * time.Second,
        }

        // Create a rate limiter that allows 10 requests per second with a burst of 20
        limiter := rate.NewLimiter(rate.Limit(10), 20)

        return &amp;BochaService{
                apiKey:     cfg.BochaAPIKey,
                apiBaseURL: cfg.BochaAPIBaseURL,
                httpClient: &amp;http.Client{
                        Timeout:   cfg.HTTPTimeout,
                        Transport: transport,
                },
                rateLimiter: limiter,
        }
}</span>

// Search performs a search using the Bocha AI Search API
func (s *BochaService) Search(ctx context.Context, query string, freshness string, count int, answer bool) (*Response, error) <span class="cov8" title="1">{
        // Apply rate limiting
        if err := s.rateLimiter.Wait(ctx); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("rate limit exceeded: %w", err)
        }</span>

        // Validate inputs
        <span class="cov8" title="1">if query == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("search query cannot be empty")
        }</span>

        // Sanitize the query to prevent potential injection attacks
        <span class="cov8" title="1">query = sanitizeQuery(query)

        // Validate freshness parameter if provided
        if freshness != "" &amp;&amp; freshness != "noLimit" &amp;&amp; freshness != "day" &amp;&amp; freshness != "week" &amp;&amp; freshness != "month" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid freshness value: %q, must be one of: noLimit, day, week, month", freshness)
        }</span>

        <span class="cov8" title="1">if count &lt; 1 </span><span class="cov8" title="1">{
                count = 1
        }</span> else<span class="cov8" title="1"> if count &gt; 50 </span><span class="cov8" title="1">{
                count = 50
        }</span>

        // Create the request payload
        <span class="cov8" title="1">reqBody := Request{
                Query:     query,
                Freshness: freshness,
                Count:     count,
                Answer:    answer,
                Stream:    false, // We don't support streaming in this implementation
        }

        // Convert the request to JSON
        jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        // Create the HTTP request
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "POST", s.apiBaseURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        // Set headers
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", s.apiKey))
        req.Header.Set("User-Agent", "BochaAISearchMCPServer/1.0")

        // Send the request
        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request to Bocha API: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Read the response body with a size limit to prevent memory exhaustion
        body, err := io.ReadAll(io.LimitReader(resp.Body, 10*1024*1024)) // 10MB limit
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read Bocha API response body: %w", err)
        }</span>

        // Check for non-200 status code
        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                // Try to extract error message from response if possible
                var errorResp struct {
                        Error string `json:"error"`
                }
                if err := json.Unmarshal(body, &amp;errorResp); err == nil &amp;&amp; errorResp.Error != "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("Bocha API error (status %d): %s", resp.StatusCode, errorResp.Error)
                }</span>

                // Don't return the full response body in case of error to avoid leaking sensitive information
                <span class="cov0" title="0">return nil, fmt.Errorf("Bocha API returned status code %d", resp.StatusCode)</span>
        }

        // Parse the response
        <span class="cov8" title="1">var searchResp Response
        if err := json.Unmarshal(body, &amp;searchResp); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse Bocha API response: %w", err)
        }</span>

        // Validate response
        <span class="cov8" title="1">if searchResp.Results == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Bocha API returned empty or invalid response")
        }</span>

        <span class="cov8" title="1">return &amp;searchResp, nil</span>
}

// sanitizeQuery performs basic sanitization on the search query
// to prevent potential injection attacks
func sanitizeQuery(query string) string <span class="cov8" title="1">{
        // This is a simple implementation - in a production environment,
        // you might want to use a more sophisticated sanitization library

        // Limit query length to prevent DoS attacks
        const maxQueryLength = 1000
        if len(query) &gt; maxQueryLength </span><span class="cov8" title="1">{
                query = query[:maxQueryLength]
        }</span>

        <span class="cov8" title="1">return query</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
